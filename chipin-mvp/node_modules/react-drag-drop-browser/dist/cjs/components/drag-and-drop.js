"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DragAndDrop;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const join_classes_1 = require("../lib/join-classes");
const initState = {
    dropped: false,
    dragging: false,
    inDropZone: false,
};
function DragAndDrop(props) {
    const { zoneId = "hot-zone", dataTestId = "hot-zone", maxSizeInMB = 1, children = "Drop files here", inZoneClassName = "inside-hot-zone", zoneClassName = "hot-zone", render = undefined, onDropFiles, } = props;
    const sizeInBytes = maxSizeInMB * 1024 * 1024;
    const [state, setState] = (0, react_1.useState)(initState);
    const resetState = () => {
        setState(initState);
    };
    const handleDragEnter = (e) => {
        e.preventDefault();
        e.stopPropagation();
        // During ENTER, we want to check if the event is triggered by the DnD zone
        // If yes, then we're within the zone
        const target = e.target;
        const currentTarget = e.currentTarget;
        const relatedTarget = e.relatedTarget;
        const triggeredByHotZone = (target === null || target === void 0 ? void 0 : target.id) === zoneId;
        const eventInDropZone = triggeredByHotZone || (currentTarget === null || currentTarget === void 0 ? void 0 : currentTarget.contains(relatedTarget));
        setState((prev) => (Object.assign(Object.assign({}, prev), { dropped: false, inDropZone: eventInDropZone })));
    };
    const handleDragLeave = (e) => {
        e.preventDefault();
        e.stopPropagation();
        // During LEAVE, we want to check if the event trigger is located within the DnD zone
        // because this time we're assumed to be already inside the borders of the DnD zone
        // If the event is triggered by something OUTSIDE of the DnD zone, then we're no longer
        // inside the borders of the DnD zone
        const currentTarget = e.currentTarget;
        const relatedTarget = e.relatedTarget;
        const eventInDropZone = currentTarget === null || currentTarget === void 0 ? void 0 : currentTarget.contains(relatedTarget);
        setState((prev) => (Object.assign(Object.assign({}, prev), { dropped: false, inDropZone: eventInDropZone })));
    };
    const handleDragOver = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const target = e.target;
        const currentTarget = e.currentTarget;
        e.dataTransfer.dropEffect = "copy";
        setState((prev) => (Object.assign(Object.assign({}, prev), { dragging: true, inDropZone: currentTarget === null || currentTarget === void 0 ? void 0 : currentTarget.contains(target) })));
    };
    const handleDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const fileArray = Array.from(e.dataTransfer.files).filter((file) => file.size <= sizeInBytes);
        onDropFiles(fileArray);
        resetState();
    };
    if (render) {
        const renderWithId = (renderProps) => {
            const renderedNode = render(renderProps);
            return (0, react_1.cloneElement)(renderedNode, { id: zoneId });
        };
        return renderWithId({
            state,
            resetState,
            onDrop: handleDrop,
            onDragEnter: handleDragEnter,
            onDragLeave: handleDragLeave,
            onDragOver: handleDragOver,
        });
    }
    return ((0, jsx_runtime_1.jsx)("section", { id: zoneId, "data-testid": dataTestId, "aria-labelledby": "Drag and drop zone", className: (0, join_classes_1.classNames)(zoneClassName, state.inDropZone ? inZoneClassName : ""), onBlur: resetState, onDrop: handleDrop, onDragOver: handleDragOver, onDragEnter: handleDragEnter, onDragLeave: handleDragLeave, children: children }));
}
